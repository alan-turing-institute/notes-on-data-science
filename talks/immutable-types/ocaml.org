#+title: How to write programs
#+PROPERTY: header-args    :tangle yes


* I Philosophy

As you know, there is a group in the Turing known as REG. You may have
seen one of them. If you looked at their computer screen, you will
likely find that they are doing something called “programming.”

Perhaps you have watched a REG person “programming” and thought, that
looks like fun. Perhaps you have even thought to yourself, I wish /I/
could program. Well, today I thought I would tell you how to program.

Before I can tell you /how/ to program, I had better just explain
/what/ it is that they are doing. What /is/ a program?

Let me give you an example that I hope will make it clear. Once a
year, in December, many people in REG stop whatever inessential
activity they are doing, and devote their time to the extremely
important task of solving a series of programming challenges, known as
Advent of Code. Programmers all over the world undertake these
challenges and it is critical that they do so. For, if a programmer is
unable to complete these challenges they will lose their progamming
license and then there will be nothing for it but to become a manager.

Here is the first challenge from a few years ago.

https://adventofcode.com/2022/day/1

There are a lot of words here so let me clarify the puzzle. You are
given a series of numbers, like these, separated into groups by blank
lines. This is the /puzzle input/. The task is to first find the sum
of the numbers in each group, and then to find the largest such sum;
that is the answer. In this example, the answer is 24000.

To solve this puzzle, one writes a program. When run, that program
takes, as its input, these numbers and produces, as output, the
required answer. That is, it computes the required answer.

Of course, it would be silly if the program *always* produced the same
answer whatever input it was given. The program must be flexible
enough to compute the answers corresponding to other possible
inputs. Indeed, these numbers are just an example to help you
understand the puzzle, they are not the real input. The real input is
here.

So we can see that a program is a kind of description of a
computation. And a computation is a process which consumes some input
and produces some output. If you are mathematically inclined, you will
recognise this as a function. A program is a description of the steps
involved in computing a function.

In fact, in programming, we use the word "function" for exactly this
kind of thing: a little program that consumes a value and produces a
value. To program is to describe how to compute a function. 


* II Values

Alright, let's learn a programming language!

The very first thing we need to know is what kind of things can our
program consume and produce? Such things are called /values/.

The philosophy of this talk is:

- Every value is the value of some type;
- Functions map types to types;
- Programs are functions
  


* III Example functions

#+begin_src ocaml :tangle yes
  string_of_int 12 ;;
  int_of_string 13 ;;

  succ 0 ;;
  pred 1 ;;

  is_zero 0 ;;
  is_zero 1 ;;

  not true ;;

  let foo = 2;;
#+end_src

In this language, to apply a function to a value we write the
function, then a space, then the value.

Other languages do this differently. Some languages write parentheses
around the argument. Some languages wrap the whole expression in
parentheses. That's because in the those languages some functions
consume more than one value at once and without the parentheses are
necessary to surround the multiple values. But in OCaml, every
function consumes exactly one value.

Notice that each function consumes a value of a particular type. It
doesn't make sense to give a string to ~is_zero~, for example, and we
get an error should we try to do so.

Going back to our advent of code problem, in some sense our input is a
string (that is, a sequence of characters) and so is our output. So we
are going to write a function that consumes a value of type string and
produces a value of type string. 

We can give names to values.


* IV Constructing new functions

What we have so far is a really a calculator. But the essence of
programming, according to the philosophy of this talk, consists in
building new functions. How can we make new functions?

One obvious way is to compose two existing functions, one after the
other, by using one function to consume the output of another. For
example, we could say, ~is_nonzero~ is the function that first applies
~is_zero~, then applies ~not~.

In this language, we make a function and give it a name at the same
time using the keyword ~let~:

#+begin_src ocaml
  let is_nonzero n =
    not (is_zero n)

  let add2 n =
    succ (succ n)
#+end_src

We're saying: to apply ~is_nonzero~ to some value, let's call it ~n~,
first apply ~is_zero~ to ~n~, then apply ~not~ to the result of
that. To apply ~add2~ to some value, call it ~n~, apply ~succ~ to ~n~,
then apply ~succ~ to that.

Great! We've written two programs!

You might wonder why we needed the ~n~ at all. There's not much else we
can do, so far, other than compose two functions. Couldn't we have
written something like ~not ∘ is_zero~? We might return to this.

I think you can see that we can write some programs but not very
many. All the programs we can write so far are the composition of a
sequence of built-in functions, one after another. That feels
limiting.


* V Product types

You might have noticed a problem.

So far we have three types: ~int~, ~bool~, and ~string~. And every
value is a value of some type. But the input to the Advent of Code
puzzle is certainly neither an ~int~ nor a ~bool~. Perhaps it is a
~string~? Really, we want to be able to think of it as “a collection
of groups of ints.”

We want to be able to talk about values that are “collections of other
values.”

Luckily, OCaml comes with a way to make types containing two
values. The types are called product types. The value is a pair. For
example:
#+begin_src ocaml
  (3, "widgets") 
#+end_src
That is a single value, of type ~int * string~. It is a pair of an
~int~ and a ~string~. The parentheses are special syntax to construct
values of this type.

One can make products of any type. You can make products of types that
are themselves products. This product is a pair of an ~int~ and a pair
of a ~string~ and a ~bool~. There are three values in it.

OCaml has a convenience for products of three or more types, which is
called a tuple. We won't use tuples. However, once one has products of
many types, one might ask, what is the product of /no/ types? That is
a special type, called ~unit~. There is only one value of type
~unit~.  
#+begin_src ocaml
  ()
#+end_src


* VI Function types

There's a question that has perhaps been bothering you. Every function
-- every program -- consumes a single argument. So how are we supposed
to add two numbers? That seems like a pretty fundamental thing to want
to compute.

Well, the answer has probably occured to you. The function ~add~
should take a single argument that is a pair. For example, to add two
integers, obviously you should write:
#+begin_src ocaml
  Int.add (1, 2)
#+end_src

Well, that doesn't work! It turns out OCaml doesn't do things this
way. To understand what it does do, it's necessary to make a little
digression.

Let's look back at ~succ~. ~succ~ is a name for the function.
#+begin_src ocaml
  succ
#+end_src
The type of ~succ~ is ~int -> int~. That means "the type of functions
which consume an ~int~ and return an ~int~." And ~succ~ is certainy of
type since it does consume an ~int~ and return an ~int~. So functions
have types. That is, functions are also values.

We've been drawing types as circles and functions as arrows, and
that's correct; but it turns out that functions are also values and
have a type. So those types had better go on the diagram as well.

Here are the types for two of the functions we saw earlier.

But now, ~int->int~ /is/ a type. And functions map types to types. So
we ought to be able to construct this type, ~int->(int->int)~. That's
the type of functions that takes an ~int~ and returns a value of type
~int->int~. That is, it returns a function.

What use is a function that consumes an ~int~ and returns a function?
Well, here's the actual ~add~ function in OCaml:
#+begin_src ocaml
  add;;
#+end_src
That's just this type! (Well, there are no parentheses. But the arrow
is associative to the right.)  ~add~ consumes an ~int~, say ~5~. And
it returns a function. Which function? The function that adds ~5~ to
its argument.
#+begin_src ocaml
  add 5;;
#+end_src
And you apply that function in the usual way:
#+begin_src ocaml
  (add 5) 3;;
#+end_src
In fact, function application is associative to the left, so you don't
need the parentheses:
#+begin_src ocaml
  add 5 3;;
#+end_src

Why does OCaml do it this way? Maybe they *really* hate
parentheses. It's common to ML-family languages. Haskell is the same.

Anyway, this is how we write what are effectively function of two
values in OCaml.


* VII New versions of existing types

Computers communicate with each other through "ports". A port is
identified by a number. If we wanted to write programs that dealt with
ports, we might like to have a type whose values are ports but which
are secretly ~ints~.

#+begin_src ocaml
  type port = Port of int
#+end_src

This creates an entirely new type, called ~port~, that is an identical
copy of ~int~. You can get hold of a value of type ~port~ like this: ~Port
8080~. The name that starts with a capital letter is a /data
constructor/: it constructs a value of type ~port~ given a value of type
~int~. It's the only way to get a value of type ~port~. The ~port~ type is a
copy of the ~int~ type, but it is not an ~int~: you can't use a ~port~ where
an ~int~ is expected:

#+begin_src ocaml
  succ (Port 8080)
#+end_src

How do you get the ~int~ out of a ~Port~? There are several ways, but
the one we will use is with ~match~.

#+begin_src ocaml
  let p = Port 8080 ;;

  let int_of_port n = 
    match p with
      (Port n) -> n ;;
#+end_src

This says, "~p~ should be ~Port n~, for some ~n~. Give back the ~n~". 

Getting values into a ~port~, using the constructor, looks like a
function, but getting them out seems to involve special syntax. On the
other hand, getting values of a pair involved special syntax, but
getting values out of the pair uses functions.

So far, we've seen product types that can hold two values of different
types. There is another type that may seem less familiar. That is a
type that can hold a value that can come from several other types, but
remembers which one it came from.

#+begin_src ocaml
  type length = Metres of int | Centimetres of int

  let l = Metres 2
#+end_src

This type holds either metres or feet. To get a value out of this
type, we use ~match~ again. 

#+begin_src ocaml :results output
  let length_in_centimetres l =
    match l with
    | Metres m -> 100 * m
    | Centimetres c -> c 
#+end_src

#+RESULTS:

* Inductive data types




