#+title: Five little programs in OCaml
#+PROPERTY: header-args    :tangle yes :comments org
#+options: toc:nil

* Introduction [15 mins?]

This is part three of my on-again, off-again series of talks about
functional programming. I've enjoyed thinking about these so thank you
for giving me the opportunity to talk again.

We write programs. Sometimes we teach other people to program. One
question you might wonder about is, what /is/ a program?

Let me describe two complementary ways to think about what a computer
program is.

- One way, which is perhaps the usual way, starts by acknowledging
  that there are, in this world, things called computers, and we wish
  to make them do stuff. Real computers are, at heart, Turing
  machines. They execute a small number of built-in
  instructions. These built-in instructions are very primitive. They
  include: reading or writing a memory location; and branching to a
  different part of the sequence depending on the value of those
  memory locations. That's pretty much it.

- A program is a sequence of these instructions. To learn to program
  is, in part, to learn how to choose and arrange the appropriate
  sequence of these instructions so that, after the computer has
  executed them, the thing you want to happen will have happened.
 
- It's very painful to write a program with such primitive
  instructions, as you will know if you've ever written
  assembly. Higher-level programming languages are there to make it
  easier to produce the sequence of instructions. They add convenience
  features like names for memory locations, procedures, and for loops.
  
- So learning to program also involves learning the various
  convenience and abstraction facilities provided by your favourite
  programming language.

- Now I'd like to tell you about another way to think about
  programming. Although it seems ridiculous, I'd like you to forget,
  for a moment, that real, physical, computers exist. I want to ask,
  what is a computation actually /for/?

- Every year, some of us try the Advent of Code programming
  puzzles.

- Here's an example https://adventofcode.com/2022/day/1

- To solve these puzzles, one must write a program which, given some
  puzzle input, produces the solution as output. The program has to
  consume the puzzle input and emit the answer. That is, it computes a
  function.

- The puzzle /describes/ a function: It tells you /how/ the output
  should be related to the input. But it does not explain how to
  /compute/ the outupt. That's why it's a puzzle! Writing a program
  means explicitly describing the steps required to compute the value
  of this function.

- So we might ask, can we describe this process, of computing the
  value of a function, without reference to real computers? It turns
  out that there is such a way. One starts with primitive functions --
  ones that are very simple -- together with ways to combine these
  primitive funtions to make more complex ones.
  
- On this view, learning to program has two parts, just as before:
  - First, what kinds of things are allowed as the inputs to and
    outputs from a program, and how does one construct more complex
    functions out of simpler ones? 
  - And second, what facilities does your programming language provide
    to make this process easier?

- Just like before, the first part is the hardest, because it's
  conceptual.

I'd like to tell you a little bit about the first part. That is, what
is it like to program, if we think of programming as an exercise in
creating functions?

I will use the language OCaml because it has a strong functional
core. OCaml will probably be unfamiliar to you, both because its
syntax is slightly different from Python but also because its
underlying philosophy is functional. I'll try to use just that part of
OCaml that illustrates these functional ideas.


* Types and programs

** Built-ins

[First slide]

I will start by describing some of the built-in, primitive functions
in OCaml.

Dijsktra once said that the art of programming is the art of
organising complexity.

One of the ways that OCaml manages complexity is to restrict the kinds
of things that can be inputs to, and outputs from, a particular
function. An input to, our output from, a function, is a value; and
every value has a type. Every function accepts only values of a
certain type and produces only values of a certain type. So we need to
know what types there are. Here are three built-in types.

[Show some examples of int, bool, and string.]

The language also provides us with some built-in functions which work
with these built-in types. Here are some examples.

#+begin_src ocaml
  string_of_int 12

  succ 0
  pred 1

  not true
#+end_src

In Python, you might be used to writing parentheses around the
arguments to a function, but OCaml simply uses a space. Parentheses
are instead used for grouping.

We can make other functions out of these built-in functions by
applying one function to the output of another. For example,

#+begin_src ocaml
  (* Program 1 *)
  
  let add2 x =
    succ (succ x) 
#+end_src

~let~ is a keyword. It defines what you mean by ~add2 x~, which
is to apply ~succ~ to ~x~ and then to apply ~succ~ to the result. We
had to group the argument to the outer ~succ~ otherwise OCaml would
attempt to apply ~succ~ to ~succ~.

OCaml programs are checked by the compiler to ensure that functions
are only applied to values of the correct type. If we apply ~succ~ to
something that the compiler cannot prove is an ~int~, the result is a
compiler error. Not all functional languages are like this, but OCaml
is.

** Function types

Well, now we can write lots of programs! But not very interesting
ones. Only boring ones like ~add2~ and ~string_of_int~ of ~add2~.

We've talked about three kinds of entity in an OCaml program. There
are functions; functions consume and emit values; and values have
types. The picture shows some types and some functions.

It turns out that in a functional language, functions are themselves
values. Perhaps this is one of the defining features of a functional
language. What I mean is that functions can consume functions and emit
functions. In some sense, we write programs that create programs. 

If functions are values, they must have a type.

The type of ~succ~ is ~int->int~. It's a function that consumes an
~int~ and produces an ~int~. All functions from ~int~ s to ~int~ s are
values of this type.

One could imagine a function that consumes an ~int~ and produces a
value of type ~int->int~. You would give this function a number, and
it would return a function waiting for another number.

This is how OCaml defines addition.

#+begin_src ocaml
  add 2 3
#+end_src

Remember, space means function application. And function application
associates to the left, so this is the same as ~(add 2) 3~.

Here's an alternative way to define ~add2~:

#+begin_src ocaml
  (* Program 2 *)

  let add2 = (add 2)
#+end_src

Another example of this kind of thing is ~equal~, which is used to
compare two ~int~ s.

And of course, since functions are values, ~add~ itself has a type.  

By the way, just like Python, OCaml has some syntax that makes
arithmetic easier: We can write ~2 + 3~ and ~2 = 3~.

** Product types

Alright. We still can't write very interesting programs. In
particular, we can't solve the advent of code puzzle. If we could
solve the advent of code puzzle, it would look a bit like this. The
input and output are of course strings, but to do anything useful will
need to think of the input in a more structured way. In particular,
it's a collection of groups of numbers.

We want to be able to talk about values that are “collections of other
values.”

OCaml comes with a way to make types containing two values. The types
are called product types. The value is called a pair. For example:
#+begin_src ocaml
  (true, "widgets") 
#+end_src
That is a single value, of type ~bool * string~. It is a pair of an
~bool~ and a ~string~. The parentheses are special syntax to construct
values of this type.

Pairs come already equipped with two special functions, ~fst~ and
~snd~. They pull out the first and second elements.

#+begin_src ocaml
  fst (true, "widgets")
#+end_src

One can make products of any type. You can make products of types that
are themselves products. This product is a pair of an ~int~ and a pair
of a ~int~ and a ~int~. There are three values in it.

This is great, because maybe we can use tuples for the Advent of
Code. We could represent the groups of ~int~ s as a pair, or as three
things, or four things, however many there are.

But this doesn't quite work. The problem is that we don't know, in
advance, how many numbers there will be in a group. We need a type
that is “either a number, or a pair of numbers, or three numbers, or
...”.

Of course, you will immediately think of a list or a vector. And
indeed OCaml does have lists. But ... it's worthwhile seeing if we
could have created them if the language did not have them. I think
languages are powerful to the extent that they let you add what look
like new language features as a library; that is, without changing the
compiler.

** Sum types

Here's a new type, a copy of ~int~. It could be used to hold values
that represent computer networking ports.

Suppose we want a function that converts a port to its well-known
name, as a string. It will be something like:

#+begin_src ocaml
  let portName p =
    match p with
    | 20 -> "FTP"
    | 80 -> "HTTP"
    | _  -> ??
#+end_src

Sometimess there isn't a well-known name. What should we return? It
feels wrong to return a string -- the return value is supposed to be
the name of a well-known type.

Here's a type that can hold a string, or a special value, created with
~None~:

#+begin_src ocaml
  type stringoption =
    | None
    | Some of string
#+end_src

#+begin_src ocaml
  let portName p =
    match p with
    | 20 -> Some "FTP"
    | 80 -> Some "HTTP"
    | _  -> None
#+end_src

* Advent of Code











